{"version":3,"file":"tmx-parser.umd.js","sources":["../index.js"],"sourcesContent":["var sax = require('sax');\nvar fs = require('fs');\nvar path = require('path');\nvar zlib = require('zlib');\nvar Pend = require('pend');\n\nexports.readFile = defaultReadFile;\nexports.parseFile = parseFile;\nexports.parse = parse;\nexports.Map = Map;\nexports.TileSet = TileSet;\nexports.Image = Image;\nexports.Tile = Tile;\nexports.TileLayer = TileLayer;\nexports.ObjectLayer = ObjectLayer;\nexports.ImageLayer = ImageLayer;\nexports.TmxObject = TmxObject;\nexports.Terrain = Terrain;\n\nvar FLIPPED_HORIZONTALLY_FLAG = 0x80000000;\nvar FLIPPED_VERTICALLY_FLAG   = 0x40000000;\nvar FLIPPED_DIAGONALLY_FLAG   = 0x20000000;\n\nvar STATE_COUNT = 0;\nvar STATE_START                = STATE_COUNT++;\nvar STATE_MAP                  = STATE_COUNT++;\nvar STATE_COLLECT_PROPS        = STATE_COUNT++;\nvar STATE_COLLECT_ANIMATIONS   = STATE_COUNT++;\nvar STATE_COLLECT_OBJECT_GROUPS = STATE_COUNT++;\nvar STATE_WAIT_FOR_CLOSE       = STATE_COUNT++;\nvar STATE_TILESET              = STATE_COUNT++;\nvar STATE_TILE                 = STATE_COUNT++;\nvar STATE_TILE_LAYER           = STATE_COUNT++;\nvar STATE_OBJECT_LAYER         = STATE_COUNT++;\nvar STATE_OBJECT               = STATE_COUNT++;\nvar STATE_TILE_OBJECT          = STATE_COUNT++;\nvar STATE_IMAGE_LAYER          = STATE_COUNT++;\nvar STATE_TILE_DATA_XML        = STATE_COUNT++;\nvar STATE_TILE_DATA_CSV        = STATE_COUNT++;\nvar STATE_TILE_DATA_B64_RAW    = STATE_COUNT++;\nvar STATE_TILE_DATA_B64_GZIP   = STATE_COUNT++;\nvar STATE_TILE_DATA_B64_ZLIB   = STATE_COUNT++;\nvar STATE_TERRAIN_TYPES        = STATE_COUNT++;\nvar STATE_TERRAIN              = STATE_COUNT++;\n\nfunction parse(content, pathToFile, cb) {\n  var pathToDir = path.dirname(pathToFile);\n  var parser = sax.parser();\n  var map;\n  var topLevelObject = null;\n  var state = STATE_START;\n  var states = new Array(STATE_COUNT);\n  var waitForCloseNextState = 0;\n  var waitForCloseOpenCount = 0;\n  var propertiesObject = null;\n  var propertiesNextState = 0;\n  var animationsObject = null;\n  var animationsNextState = 0;\n  var objectGroupsObject = null;\n  var objectGroupsNextState = 0;\n  var tileIndex = 0;\n  var tileSet = null;\n  var tileSetNextState = 0;\n  var tile;\n  var layer;\n  var object;\n  var terrain;\n  var pend = new Pend();\n  // this holds the numerical tile ids\n  // later we use it to resolve the real tiles\n  var unresolvedLayers = [];\n  var unresolvedLayer;\n  states[STATE_START] = {\n    opentag: function(tag) {\n      if (tag.name === 'MAP') {\n        map = new Map();\n        topLevelObject = map;\n        map.version = tag.attributes.VERSION;\n        map.orientation = tag.attributes.ORIENTATION;\n        map.width = int(tag.attributes.WIDTH);\n        map.height = int(tag.attributes.HEIGHT);\n        map.tileWidth = int(tag.attributes.TILEWIDTH);\n        map.tileHeight = int(tag.attributes.TILEHEIGHT);\n        map.backgroundColor = tag.attributes.BACKGROUNDCOLOR;\n\n        state = STATE_MAP;\n      } else if (tag.name === 'TILESET') {\n        collectTileSet(tag, STATE_START);\n        topLevelObject = tileSet;\n      } else {\n        waitForClose();\n      }\n    },\n    closetag: noop,\n    text: noop,\n  };\n  states[STATE_MAP] = {\n    opentag: function(tag) {\n      switch (tag.name) {\n        case 'PROPERTIES':\n          collectProperties(map.properties);\n          break;\n        case 'TILESET':\n          collectTileSet(tag, STATE_MAP);\n          map.tileSets.push(tileSet);\n          break;\n        case 'LAYER':\n          layer = new TileLayer(map);\n          tileIndex = 0;\n          layer.name = tag.attributes.NAME;\n          layer.opacity = float(tag.attributes.OPACITY, 1);\n          layer.visible = bool(tag.attributes.VISIBLE, true);\n          map.layers.push(layer);\n          unresolvedLayer = {\n            layer: layer,\n            tiles: new Array(map.width * map.height),\n          };\n          unresolvedLayers.push(unresolvedLayer);\n          state = STATE_TILE_LAYER;\n          break;\n        case 'OBJECTGROUP':\n          layer = new ObjectLayer();\n          layer.name = tag.attributes.NAME;\n          layer.color = tag.attributes.COLOR;\n          layer.opacity = float(tag.attributes.OPACITY, 1);\n          layer.visible = bool(tag.attributes.VISIBLE, true);\n          map.layers.push(layer);\n          state = STATE_OBJECT_LAYER;\n          break;\n        case 'IMAGELAYER':\n          layer = new ImageLayer();\n          layer.name = tag.attributes.NAME;\n          layer.x = int(tag.attributes.X);\n          layer.y = int(tag.attributes.Y);\n          layer.opacity = float(tag.attributes.OPACITY, 1);\n          layer.visible = bool(tag.attributes.VISIBLE, true);\n          map.layers.push(layer);\n          state = STATE_IMAGE_LAYER;\n          break;\n        default:\n          waitForClose();\n      }\n    },\n    closetag: noop,\n    text: noop,\n  };\n  states[STATE_TILESET] = {\n    opentag: function(tag) {\n      switch (tag.name) {\n        case 'TILEOFFSET':\n          tileSet.tileOffset.x = int(tag.attributes.X);\n          tileSet.tileOffset.y = int(tag.attributes.Y);\n          waitForClose();\n          break;\n        case 'PROPERTIES':\n          collectProperties(tileSet.properties);\n          break;\n        case 'IMAGE':\n          tileSet.image = collectImage(tag);\n          break;\n        case 'TERRAINTYPES':\n          state = STATE_TERRAIN_TYPES;\n          break;\n        case 'TILE':\n          tile = new Tile();\n          tile.id = int(tag.attributes.ID);\n          if (tag.attributes.TERRAIN) {\n            var indexes = tag.attributes.TERRAIN.split(\",\");\n            tile.terrain = indexes.map(resolveTerrain);\n          }\n          tile.probability = float(tag.attributes.PROBABILITY);\n          tileSet.tiles[tile.id] = tile;\n          state = STATE_TILE;\n          break;\n        default:\n          waitForClose();\n      }\n    },\n    closetag: function(name) {\n      state = tileSetNextState;\n    },\n    text: noop,\n  };\n  states[STATE_COLLECT_PROPS] = {\n    opentag: function(tag) {\n      if (tag.name === 'PROPERTY') {\n        propertiesObject[tag.attributes.NAME] = parseProperty(\n          tag.attributes.VALUE,\n          tag.attributes.TYPE\n        );\n      }\n      waitForClose();\n    },\n    closetag: function(name) {\n      state = propertiesNextState;\n    },\n    text: noop,\n  };\n  states[STATE_COLLECT_ANIMATIONS] = {\n    opentag: function(tag) {\n      if (tag.name === 'FRAME') {\n          animationsObject.push({\n              'tileId': tag.attributes.TILEID,\n              'duration': tag.attributes.DURATION\n          });\n      }\n      waitForClose();\n    },\n    closetag: function(name) {\n      state = animationsNextState;\n    },\n    text: noop,\n  };\n  states[STATE_COLLECT_OBJECT_GROUPS] = {\n    opentag: function(tag) {\n      if (tag.name === 'OBJECT') {\n        object = new TmxObject();\n        object.name = tag.attributes.NAME;\n        object.type = tag.attributes.TYPE;\n        object.x = int(tag.attributes.X);\n        object.y = int(tag.attributes.Y);\n        object.width = int(tag.attributes.WIDTH, 0);\n        object.height = int(tag.attributes.HEIGHT, 0);\n        object.rotation = float(tag.attributes.ROTATION, 0);\n        object.gid = int(tag.attributes.GID);\n        object.visible = bool(tag.attributes.VISIBLE, true);\n        objectGroupsObject.push(object);\n        state = STATE_TILE_OBJECT;\n      } else {\n        waitForClose();\n      }\n    },\n    closetag: function(name) {\n      state = objectGroupsNextState;\n    },\n    text: noop\n  };\n  states[STATE_WAIT_FOR_CLOSE] = {\n    opentag: function(tag) {\n      waitForCloseOpenCount += 1;\n    },\n    closetag: function(name) {\n      waitForCloseOpenCount -= 1;\n      if (waitForCloseOpenCount === 0) state = waitForCloseNextState;\n    },\n    text: noop,\n  };\n  states[STATE_TILE] = {\n    opentag: function(tag) {\n      if (tag.name === 'PROPERTIES') {\n        collectProperties(tile.properties);\n      } else if (tag.name === 'IMAGE') {\n        tile.image = collectImage(tag);\n      } else if (tag.name === 'ANIMATION') {\n        tile.animation = collectAnimations(tile.animations);\n      } else if (tag.name === 'OBJECTGROUP') {\n        tile.objectGroup = collectObjectGroups(tile.objectGroups);\n      } else {\n        waitForClose();\n      }\n    },\n    closetag: function(name) {\n      state = STATE_TILESET\n    },\n    text: noop,\n  };\n  states[STATE_TILE_LAYER] = {\n    opentag: function(tag) {\n      if (tag.name === 'PROPERTIES') {\n        collectProperties(layer.properties);\n      } else if (tag.name === 'DATA') {\n        var dataEncoding = tag.attributes.ENCODING;\n        var dataCompression = tag.attributes.COMPRESSION;\n        switch (dataEncoding) {\n          case undefined:\n          case null:\n            state = STATE_TILE_DATA_XML;\n            break;\n          case 'csv':\n            state = STATE_TILE_DATA_CSV;\n            break;\n          case 'base64':\n            switch (dataCompression) {\n              case undefined:\n              case null:\n                state = STATE_TILE_DATA_B64_RAW;\n                break;\n              case 'gzip':\n                state = STATE_TILE_DATA_B64_GZIP;\n                break;\n              case 'zlib':\n                state = STATE_TILE_DATA_B64_ZLIB;\n                break;\n              default:\n                error(new Error(\"unsupported data compression: \" + dataCompression));\n                return;\n            }\n            break;\n          default:\n            error(new Error(\"unsupported data encoding: \" + dataEncoding));\n            return;\n        }\n      } else {\n        waitForClose();\n      }\n    },\n    closetag: function(name) {\n      state = STATE_MAP;\n    },\n    text: noop,\n  };\n  states[STATE_OBJECT_LAYER] = {\n    opentag: function(tag) {\n      if (tag.name === 'PROPERTIES') {\n        collectProperties(layer.properties);\n      } else if (tag.name === 'OBJECT') {\n        object = new TmxObject();\n        object.name = tag.attributes.NAME;\n        object.type = tag.attributes.TYPE;\n        object.x = int(tag.attributes.X);\n        object.y = int(tag.attributes.Y);\n        object.width = int(tag.attributes.WIDTH, 0);\n        object.height = int(tag.attributes.HEIGHT, 0);\n        object.rotation = float(tag.attributes.ROTATION, 0);\n        object.gid = int(tag.attributes.GID);\n        object.visible = bool(tag.attributes.VISIBLE, true);\n        layer.objects.push(object);\n        state = STATE_OBJECT;\n      } else {\n        waitForClose();\n      }\n    },\n    closetag: function(name) {\n      state = STATE_MAP;\n    },\n    text: noop,\n  };\n  states[STATE_IMAGE_LAYER] = {\n    opentag: function(tag) {\n      if (tag.name === 'PROPERTIES') {\n        collectProperties(layer.properties);\n      } else if (tag.name === 'IMAGE') {\n        layer.image = collectImage(tag);\n      } else {\n        waitForClose();\n      }\n    },\n    closetag: function(name) {\n      state = STATE_MAP;\n    },\n    text: noop,\n  };\n  states[STATE_OBJECT] = {\n    opentag: function(tag) {\n      switch (tag.name) {\n        case 'PROPERTIES':\n          collectProperties(object.properties);\n          break;\n        case 'ELLIPSE':\n          object.ellipse = true;\n          waitForClose();\n          break;\n        case 'POLYGON':\n          object.polygon = parsePoints(tag.attributes.POINTS);\n          waitForClose();\n          break;\n        case 'POLYLINE':\n          object.polyline = parsePoints(tag.attributes.POINTS);\n          waitForClose();\n          break;\n        case 'IMAGE':\n          object.image = collectImage(tag);\n          break;\n        default:\n          waitForClose();\n      }\n    },\n    closetag: function(name) {\n      state = STATE_OBJECT_LAYER;\n    },\n    text: noop,\n  };\n  states[STATE_TILE_OBJECT] = {\n    opentag: function(tag) {\n      switch (tag.name) {\n        case 'PROPERTIES':\n          collectProperties(object.properties);\n          break;\n        case 'ELLIPSE':\n          object.ellipse = true;\n          waitForClose();\n          break;\n        case 'POLYGON':\n          object.polygon = parsePoints(tag.attributes.POINTS);\n          waitForClose();\n          break;\n        case 'POLYLINE':\n          object.polyline = parsePoints(tag.attributes.POINTS);\n          waitForClose();\n          break;\n        case 'IMAGE':\n          object.image = collectImage(tag);\n          break;\n        default:\n          waitForClose();\n      }\n    },\n    closetag: function(name) {\n      state = STATE_COLLECT_OBJECT_GROUPS;\n    },\n    text: noop\n  };\n  states[STATE_TILE_DATA_XML] = {\n    opentag: function(tag) {\n      if (tag.name === 'TILE') {\n        saveTile(int(tag.attributes.GID, 0));\n      }\n      waitForClose();\n    },\n    closetag: function(name) {\n      state = STATE_TILE_LAYER;\n    },\n    text: noop,\n  };\n  states[STATE_TILE_DATA_CSV] = {\n    opentag: function(tag) {\n      waitForClose();\n    },\n    closetag: function(name) {\n      state = STATE_TILE_LAYER;\n    },\n    text: function(text) {\n      text.split(\",\").forEach(function(c) {\n        saveTile(parseInt(c, 10));\n      });\n    },\n  };\n  states[STATE_TILE_DATA_B64_RAW] = {\n    opentag: function(tag) {\n      waitForClose();\n    },\n    closetag: function(name) {\n      state = STATE_TILE_LAYER;\n    },\n    text: function(text) {\n      unpackTileBytes(new Buffer(text.trim(), 'base64'));\n    },\n  };\n  states[STATE_TILE_DATA_B64_GZIP] = {\n    opentag: function(tag) {\n      waitForClose();\n    },\n    closetag: function(name) {\n      state = STATE_TILE_LAYER;\n    },\n    text: function(text) {\n      var zipped = new Buffer(text.trim(), 'base64');\n      var oldUnresolvedLayer = unresolvedLayer;\n      var oldLayer = layer;\n      pend.go(function(cb) {\n        zlib.gunzip(zipped, function(err, buf) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          unresolvedLayer = oldUnresolvedLayer;\n          layer = oldLayer;\n          unpackTileBytes(buf);\n          cb();\n        });\n      });\n    },\n  };\n  states[STATE_TILE_DATA_B64_ZLIB] = {\n    opentag: function(tag) {\n      waitForClose();\n    },\n    closetag: function(name) {\n      state = STATE_TILE_LAYER;\n    },\n    text: function(text) {\n      var zipped = new Buffer(text.trim(), 'base64');\n      var oldUnresolvedLayer = unresolvedLayer;\n      var oldLayer = layer;\n      pend.go(function(cb) {\n        zlib.inflate(zipped, function(err, buf) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          layer = oldLayer;\n          unresolvedLayer = oldUnresolvedLayer;\n          unpackTileBytes(buf);\n          cb();\n        });\n      });\n    },\n  };\n  states[STATE_TERRAIN_TYPES] = {\n    opentag: function(tag) {\n      if (tag.name === 'TERRAIN') {\n        terrain = new Terrain();\n        terrain.name = tag.attributes.NAME;\n        terrain.tile = int(tag.attributes.TILE);\n        tileSet.terrainTypes.push(terrain);\n        state = STATE_TERRAIN;\n      } else {\n        waitForClose();\n      }\n    },\n    closetag: function(name) {\n      state = STATE_TILESET;\n    },\n    text: noop,\n  };\n  states[STATE_TERRAIN] = {\n    opentag: function(tag) {\n      if (tag.name === 'PROPERTIES') {\n        collectProperties(terrain.properties);\n      } else {\n        waitForClose();\n      }\n    },\n    closetag: function(name) {\n      state = STATE_TERRAIN_TYPES;\n    },\n    text: noop,\n  };\n\n  parser.onerror = cb;\n  parser.onopentag = function(tag) {\n    states[state].opentag(tag);\n  };\n  parser.onclosetag = function(name) {\n    states[state].closetag(name);\n  };\n  parser.ontext = function(text) {\n    states[state].text(text);\n  };\n  parser.onend = function() {\n    // wait until async stuff has finished\n    pend.wait(function(err) {\n      if (err) {\n        cb(err);\n        return;\n      }\n      // now all tilesets are resolved and all data is decoded\n      unresolvedLayers.forEach(resolveLayer);\n      cb(null, topLevelObject);\n    });\n  };\n  parser.write(content).close();\n\n  function resolveTerrain(terrainIndexStr) {\n    return tileSet.terrainTypes[parseInt(terrainIndexStr, 10)];\n  }\n\n  function saveTile(gid) {\n    layer.horizontalFlips[tileIndex] = !!(gid & FLIPPED_HORIZONTALLY_FLAG);\n    layer.verticalFlips[tileIndex]   = !!(gid & FLIPPED_VERTICALLY_FLAG);\n    layer.diagonalFlips[tileIndex]   = !!(gid & FLIPPED_DIAGONALLY_FLAG);\n\n    gid &= ~(FLIPPED_HORIZONTALLY_FLAG |\n             FLIPPED_VERTICALLY_FLAG |\n             FLIPPED_DIAGONALLY_FLAG);\n\n    unresolvedLayer.tiles[tileIndex] = gid;\n\n    tileIndex += 1;\n  }\n\n  function collectImage(tag) {\n    var img = new Image();\n    img.format = tag.attributes.FORMAT;\n    img.source = tag.attributes.SOURCE;\n    img.trans = tag.attributes.TRANS;\n    img.width = int(tag.attributes.WIDTH);\n    img.height = int(tag.attributes.HEIGHT);\n\n    // TODO: read possible <data>\n    waitForClose();\n    return img;\n  }\n\n  function collectTileSet(tag, nextState) {\n    tileSet = new TileSet();\n    tileSet.firstGid = int(tag.attributes.FIRSTGID);\n    tileSet.source = tag.attributes.SOURCE;\n    tileSet.name = tag.attributes.NAME;\n    tileSet.tileWidth = int(tag.attributes.TILEWIDTH);\n    tileSet.tileHeight = int(tag.attributes.TILEHEIGHT);\n    tileSet.spacing = int(tag.attributes.SPACING);\n    tileSet.margin = int(tag.attributes.MARGIN);\n\n    if (tileSet.source) {\n      pend.go(function(cb) {\n        resolveTileSet(tileSet, cb);\n      });\n    }\n\n    state = STATE_TILESET;\n    tileSetNextState = nextState;\n  }\n\n  function collectProperties(obj) {\n    propertiesObject = obj;\n    propertiesNextState = state;\n    state = STATE_COLLECT_PROPS;\n  }\n\n  function collectAnimations(obj) {\n    animationsObject = obj;\n    animationsNextState = state;\n    state = STATE_COLLECT_ANIMATIONS;\n  }\n\n  function collectObjectGroups(obj) {\n    objectGroupsObject = obj;\n    objectGroupsNextState = state;\n    state = STATE_COLLECT_OBJECT_GROUPS;\n  }\n\n  function waitForClose() {\n    waitForCloseNextState = state;\n    state = STATE_WAIT_FOR_CLOSE;\n    waitForCloseOpenCount = 1;\n  }\n\n  function error(err) {\n    parser.onerror = null;\n    parser.onopentag = null;\n    parser.onclosetag = null;\n    parser.ontext = null;\n    parser.onend = null;\n    cb(err);\n  }\n\n  function resolveTileSet(unresolvedTileSet, cb) {\n    var target = path.join(pathToDir, unresolvedTileSet.source);\n    parseFile(target, function(err, resolvedTileSet) {\n      if (err) {\n        cb(err);\n        return;\n      }\n      resolvedTileSet.mergeTo(unresolvedTileSet);\n      cb();\n    });\n  }\n\n  function resolveLayer(unresolvedLayer) {\n    for (var i = 0; i < unresolvedLayer.tiles.length; i += 1) {\n      var globalTileId = unresolvedLayer.tiles[i];\n      for (var tileSetIndex = map.tileSets.length - 1;\n          tileSetIndex >= 0; tileSetIndex -= 1)\n      {\n        var tileSet = map.tileSets[tileSetIndex];\n        if (tileSet.firstGid <= globalTileId) {\n          var tileId = globalTileId - tileSet.firstGid;\n          var tile = tileSet.tiles[tileId];\n          if (!tile) {\n            // implicit tile\n            tile = new Tile();\n            tile.id = tileId;\n            tileSet.tiles[tileId] = tile;\n          }\n          tile.gid = globalTileId;\n          unresolvedLayer.layer.tiles[i] = tile;\n          break;\n        }\n      }\n    }\n  }\n\n  function unpackTileBytes(buf) {\n    var expectedCount = map.width * map.height * 4;\n    if (buf.length !== expectedCount) {\n      error(new Error(\"Expected \" + expectedCount +\n            \" bytes of tile data; received \" + buf.length));\n      return;\n    }\n    tileIndex = 0;\n    for (var i = 0; i < expectedCount; i += 4) {\n      saveTile(buf.readUInt32LE(i));\n    }\n  }\n}\n\nfunction defaultReadFile(name, cb) {\n  var isBrowser = typeof window !== 'undefined';\n\n  if (isBrowser) {\n    fetch(name)\n      .then(response => response.text())\n      .then(data => {\n        cb(undefined, data);\n      })\n      .catch(e => cb(e));\n  } else {\n    fs.readFile(name, { encoding: 'utf8' }, cb);\n  }\n}\n\nfunction parseFile(name, cb) {\n  exports.readFile(name, function(err, content) {\n    if (err) {\n      cb(err);\n    } else {\n      parse(content, name, cb);\n    }\n  });\n}\n\nfunction parsePoints(str) {\n  var points = str.split(\" \");\n  return points.map(function(pt) {\n    var xy = pt.split(\",\");\n    return {\n      x: xy[0],\n      y: xy[1],\n    };\n  });\n}\n\nfunction parseProperty(value, type) {\n  switch (type) {\n    case 'int':\n      return parseInt(value, 10);\n    case 'float':\n      return parseFloat(value, 2);\n    case 'bool':\n      return value === 'true';\n    default:\n      return value;\n  }\n\n}\n\nfunction noop() {}\n\nfunction int(value, defaultValue) {\n  defaultValue = defaultValue == null ? null : defaultValue;\n  return value == null ? defaultValue : parseInt(value, 10);\n}\n\nfunction bool(value, defaultValue) {\n  defaultValue = defaultValue == null ? null : defaultValue;\n  return value == null ? defaultValue : !!parseInt(value, 10);\n}\n\nfunction float(value, defaultValue) {\n  defaultValue = defaultValue == null ? null : defaultValue;\n  return value == null ? defaultValue : parseFloat(value, 10);\n}\n\nfunction Map() {\n  this.version = null;\n  this.orientation = \"orthogonal\";\n  this.width = 0;\n  this.height = 0;\n  this.tileWidth = 0;\n  this.tileHeight = 0;\n  this.backgroundColor = null;\n\n  this.layers = [];\n  this.properties = {};\n  this.tileSets = [];\n}\n\nfunction TileSet() {\n  this.firstGid = 0;\n  this.source = \"\";\n  this.name = \"\";\n  this.tileWidth = 0;\n  this.tileHeight = 0;\n  this.spacing = 0;\n  this.margin = 0;\n  this.tileOffset = {x: 0, y: 0};\n  this.properties = {};\n  this.image = null;\n  this.tiles = [];\n  this.terrainTypes = [];\n}\n\nTileSet.prototype.mergeTo = function(other) {\n  other.firstGid = this.firstGid == null ? other.firstGid : this.firstGid;\n  other.source = this.source == null ? other.source : this.source;\n  other.name = this.name == null ? other.name : this.name;\n  other.tileWidth = this.tileWidth == null ? other.tileWidth : this.tileWidth;\n  other.tileHeight = this.tileHeight == null ? other.tileHeight : this.tileHeight;\n  other.spacing = this.spacing == null ? other.spacing : this.spacing;\n  other.margin = this.margin == null ? other.margin : this.margin;\n  other.tileOffset = this.tileOffset == null ? other.tileOffset : this.tileOffset;\n  other.properties = this.properties == null ? other.properties : this.properties;\n  other.image = this.image == null ? other.image : this.image;\n  other.tiles = this.tiles == null ? other.tiles : this.tiles;\n  other.terrainTypes = this.terrainTypes == null ? other.terrainTypes : this.terrainTypes;\n};\n\nfunction Image() {\n  this.format = null;\n  this.source = \"\";\n  this.trans = null;\n  this.width = 0;\n  this.height = 0;\n}\n\nfunction Tile() {\n  this.id = 0;\n  this.terrain = [];\n  this.probability = null;\n  this.properties = {};\n  this.animations = [];\n  this.objectGroups = [];\n  this.image = null;\n}\n\nfunction TileLayer(map) {\n  var tileCount = map.width * map.height;\n  this.map = map;\n  this.type = \"tile\";\n  this.name = null;\n  this.opacity = 1;\n  this.visible = true;\n  this.properties = {};\n  this.tiles = new Array(tileCount);\n  this.horizontalFlips = new Array(tileCount);\n  this.verticalFlips = new Array(tileCount);\n  this.diagonalFlips = new Array(tileCount);\n}\n\nTileLayer.prototype.tileAt = function(x, y) {\n  return this.tiles[y * this.map.width + x];\n};\n\nTileLayer.prototype.setTileAt = function(x, y, tile) {\n  this.tiles[y * this.map.width + x] = tile;\n};\n\nfunction ObjectLayer() {\n  this.type = \"object\";\n  this.name = null;\n  this.color = null;\n  this.opacity = 1;\n  this.visible = true;\n  this.properties = {};\n  this.objects = [];\n}\n\nfunction ImageLayer() {\n  this.type = \"image\";\n  this.name = null;\n  this.x = 0;\n  this.y = 0;\n  this.opacity = 1;\n  this.visible = true;\n  this.properties = {};\n  this.image = null;\n}\n\nfunction TmxObject() {\n  this.name = null;\n  this.type = null;\n  this.x = 0;\n  this.y = 0;\n  this.width = 0;\n  this.height = 0;\n  this.rotation = 0;\n  this.properties = {};\n  this.gid = null;\n  this.visible = true;\n  this.ellipse = false;\n  this.polygon = null;\n  this.polyline = null;\n}\n\nfunction Terrain() {\n  this.name = \"\";\n  this.tile = 0;\n  this.properties = {};\n}\n"],"names":["sax","require","fs","path","zlib","Pend","exports","readFile","name","cb","window","fetch","then","response","text","data","undefined","e","encoding","parseFile","parse","Map","TileSet","Image","Tile","TileLayer","ObjectLayer","ImageLayer","TmxObject","Terrain","STATE_COUNT","STATE_START","STATE_MAP","STATE_COLLECT_PROPS","STATE_COLLECT_ANIMATIONS","STATE_COLLECT_OBJECT_GROUPS","STATE_WAIT_FOR_CLOSE","STATE_TILESET","STATE_TILE","STATE_TILE_LAYER","STATE_OBJECT_LAYER","STATE_OBJECT","STATE_TILE_OBJECT","STATE_IMAGE_LAYER","STATE_TILE_DATA_XML","STATE_TILE_DATA_CSV","STATE_TILE_DATA_B64_RAW","STATE_TILE_DATA_B64_GZIP","STATE_TILE_DATA_B64_ZLIB","STATE_TERRAIN_TYPES","STATE_TERRAIN","content","pathToFile","map","tile","layer","object","terrain","unresolvedLayer","pathToDir","dirname","parser","topLevelObject","state","states","Array","waitForCloseNextState","waitForCloseOpenCount","propertiesObject","propertiesNextState","animationsObject","animationsNextState","objectGroupsObject","objectGroupsNextState","tileIndex","tileSet","tileSetNextState","pend","unresolvedLayers","resolveTerrain","terrainIndexStr","terrainTypes","parseInt","saveTile","gid","horizontalFlips","verticalFlips","diagonalFlips","tiles","collectImage","tag","img","format","attributes","FORMAT","source","SOURCE","trans","TRANS","width","int","WIDTH","height","HEIGHT","waitForClose","collectTileSet","nextState","firstGid","FIRSTGID","NAME","tileWidth","TILEWIDTH","tileHeight","TILEHEIGHT","spacing","SPACING","margin","MARGIN","go","unresolvedTileSet","join","err","resolvedTileSet","mergeTo","resolveTileSet","collectProperties","obj","error","onerror","onopentag","onclosetag","ontext","onend","resolveLayer","i","length","globalTileId","tileSetIndex","tileSets","tileId","id","unpackTileBytes","buf","expectedCount","readUInt32LE","Error","opentag","version","VERSION","orientation","ORIENTATION","backgroundColor","BACKGROUNDCOLOR","closetag","noop","properties","push","opacity","float","OPACITY","visible","bool","VISIBLE","layers","color","COLOR","x","X","y","Y","tileOffset","image","ID","TERRAIN","indexes","split","probability","PROBABILITY","value","type","parseFloat","parseProperty","VALUE","TYPE","TILEID","duration","DURATION","rotation","ROTATION","GID","animation","animations","objectGroup","objectGroups","dataEncoding","ENCODING","dataCompression","COMPRESSION","objects","ellipse","polygon","parsePoints","POINTS","polyline","forEach","c","Buffer","trim","zipped","oldUnresolvedLayer","oldLayer","gunzip","inflate","TILE","wait","write","close","str","pt","xy","defaultValue","this","tileCount","prototype","other","tileAt","setTileAt"],"mappings":"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"}